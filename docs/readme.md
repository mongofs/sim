# SIM
对sim的思考，之前开源过一个项目是im，在我的github主页还能看到，其实长链接项目无非是两套重逻辑，一套是基于tcp的长链接
或者是基于websocket的长链接，本质都是连接，但是websocket可以直接利用http+tls的便车，所以如果自己实现一套tcp的长
连接其实不是特别有必要的话，我是不建议的。但是可以从网络库的角度来切入，比如原生包的net实现是BIO，也就是阻塞等待IO，那么
我们可以切换另外一套net库实现我们的底层接入逻辑，比如说基于NIO的非阻塞等待IO，目前开源的gnet、netpoll都是不错的选择，
后面为了练手也好，解耦也好，我还是有打算写一套自己的netpoll，名称叫snetpoll。

另外一套重逻辑就是查找了，当我们不论基于tcp还是websocket始终在查找逻辑看来就是一个接口，可以写，可以读，可以关闭。但是
这个话题又简单又复杂，如果单推，我们提倡的是O1时间复杂度下推，其实golang 原生的Map就已经满足需求，但是由于在业务场景中
不断有人加入，那么就不断有写，此时就是一个并发读写，那么就需要加锁，加锁可以保障数据安全，但是又会引入新的问题：锁竞争的
问题，一般出现锁问题就是减小锁的粒度，比如分段锁，在具体实现上可以参照buckt实现。

后续公司版本迭代，每个版本需要不同的内容，比如v1版本的app推送需要是json，到后面v2版本需要proto，到v3版本可能需要一个
新字段，所以需要支持多版本内容推送，在业务逻辑层将内容组织好，然后一次性推送给我去筛选，所以要支持基于tag来进行推送内容，
目前就基于这个需求开发wti这个部分，简称websocket target interface。当然这个也是非常常用的一个功能，比如说分组，或者
房间，都可以基于这个进行开发，但是每个组会单独的存放，比如一个用户有很多个tag： version_v1,room_2018，room_2019,那么
就会出现一个问题，比如某个分组有10000人，所以这个分组还需要进行人数的控制，如果超过某个阈值，就需要进行新的分组迁移，比如
我设置一个分组人数limit为1000，放在groupA中，此时又写入一个用户tag，此时触发分离用户B，肯定是需要重平衡一下的，比如：
groupA就是501人，groupB就是500人，分组规则可以通过hash取模，但是如果分组规模较大，那么此时肯定是比较耗时的，是一个On操作，
所以我建议你分组尽量不要使用超级大组，相同tag的group可以通过链表进行串联，


wti 出现后还会出现一个这样的问题：我需要给room_2018 且 version_v2的所有用户发送信息，这就是一个求交集的方案了，如果纯纯的
求交集那么就是O(n * m)的复杂度了，这里我取巧了一下，将用户的标签放到用户的结构体中，那么我只需要进行遍历较小的那个集合就可以获取
到所有的交集信息了。时间复杂度也变成了O（n）n是较小的集合。